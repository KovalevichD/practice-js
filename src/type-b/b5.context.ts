/*
 * Задача b5: Что вернет вызов функции и почему

case 1:
Будет ошибка(inc() будет не найдено), так как мы не указали контекст. При вызове метода obj.getInc интерпретатор доходит до return inc(a), и не может найти эту функцию в методе. 
Проблема решается явным указанием контекста: return this.inc(a).

const obj = {
	value: 4,
	inc: value => value + 1,
	getInc: function() {
		return inc(a);
	},
};
obj.getInc(); // ?


case 2:
Произошла потеря контекста, так как мы нарушили "правило контеста" obj.method()(контекст равен объекту перед точкой). 
Проблема решается явным указанием контекста: getInc.call(obj).

const obj = {
	value: 4,
	inc: value => value + 1,
	getInc: function() {
		return this.inc(a);
	},
};
const {getInc} = obj;
getInc(); // ?


case 3:
В "use strict" будет ошибка - Obj не определена. Нужно присвоить obj в переменную. const obj = {}. Но я так понимаю, это сдесь не важно:)
Выведет в консоль строку "foo" а затем объект obj. Потому, что в методе foo() this ссылается на объект, в контесте которого сделан вызов => obj(=this).foo().

obj = {
  foo: function () {
    console.log('foo', this); // ?
  }
}
obj.foo();


case 4:
Тут мы создаем функцию. В Js функции являются объектами. Поэтому функции мы можем присвоить метод. 
Метод foo() выведет в консоль строку 'foo' а затем функцию obj, так как obj(=this).foo().

obj = function() { } as any
obj.foo = function () {
  console.log('foo', this);
}
obj.foo(); // ?


case 5:
Выведет строку 'foo' а затем глобальный объект Window. Потому, что у стрелочных функций нет this. Но если мы его всё таки передали, то оно просто возвращает то окружение, в котором была создана функция.
Функция obj у нас "глобальная", поэтому её окружением является глобальный объект window.

obj = function() { } as any
obj.foo = () => {
  console.log('foo', this);
}
obj.foo(); // ?


case 6:
Выведет 'inner callback' затем undefined. Потому, что мы потеряли контекст. 
Проблема решается явным указанием констекста fn.call(this). Тогда бы вывело в консоль obj

obj = {
  foo: function() {
    const fn = function() {
      console.log('inner callback', this);
    }
    fn(); // ?
  }
};
obj.foo();


case 7:
То же самое, что и в задаче 6. Undefined в use strict, и window без use strict.

obj = {
  a: 1,
  foo: function(fn: any) {
    fn(); // ?
  }
};
obj.foo(function() {
  console.log('callback', this);
});


case 8:
Тут выведет в консоль массив. Мы записываем в прототип Array свой метод. Массивы в js - это объекты. Что происходит потом: Мы пытаемся вызвать у 'arr' свой метод.
Дальше поиск переходит в прототип Array.__proto__ и там находит этот метод. Почему всё таки вывело arr в консоль а не undefined? Я так думаю, потому, что мы не нарушили 
цепочку из obj.method(), поэтому контекст передался. 

var arr = [1, 2, 3, 4] as any;
(Array.prototype as any).myCustomFunc = function() {
 console.log(this);
};
arr.myCustomFunc(); // ?


case 9:
Выведет 4 раз undefined, так как анонимная функция callback никак не привязана к контексту. Чтобы решить проблему, в foreEach можно передать 2-й аргумент, который как раз
и указывает, в каком контексте работает callback.

arr = [1, 2, 3, 4];
arr.forEach(function() {
 console.log(this);
}); // ?


case 10:
Выведет 4 раза массив arr, так как передали 2-м аргументом в foreEach контекст arr.

arr = [1, 2, 3, 4];
arr.forEach(function() {
 console.log(this);
}, arr); // ?


case 11:
Выведет NaN, т.к undefined * 2 === ошибка вычислений(NaN). 
This срабатывает в момент вызова функции, метода. То есть не важно когда была создана функция или свойство, this определяется именно в момент вызова.
Как работает this в следующем вызове: obj.method(). Сначала Js "отбрасывает" скобки() и создаёт "внутреннее значение ссылочного типа". 
Это значение ссылочного типа имеет 3 значения(base, name, strict), где base - объект перед точкой, name - название метода, strict - проверяет, включен ли режим 'use strict'. 
А уже после этого, идёт вызов метода через скобки(), и this в этом методе видит через "значение ссылочного типа" в каком контексте был вызван метод. 
То есть чтобы правильно отрабатывал this, нужно чтобы вызываемый метод был таким: obj.metod(), то есть объект, точка, метод, скобки(вызов). Любые другие манипуляции ведут к потере this.
В этом примере у нас b - это не метод, это обычное свойство. Поэтому this === undefined. 

obj = {
  a: 2,
  b: this.a * 2
 };
 console.log( obj.b ); // ?


 case 12:
Тут в примере ошибка. Если бы было this.a - это пример выше. Если бы myObj.a - то ошибка, т.к. нельзя обращаться к объекту, потому что он еще инициализируется.
Эту проблему можно решить путем добавления метода b, который возвратит this.a * 2, или же alert(this.a * 2).

 var myObj = {
  a: 2,
  b: this.myObj.a * 2 // ?
 };
 */
